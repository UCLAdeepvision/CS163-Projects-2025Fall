<!DOCTYPE html>
<html lang="en">

  <head>
    
      






    

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Exploring Modern Novel View Generation Methods</title>

    <meta name="description" content="[Project Tack] Historically, novel view synthesis (NVS) has relied on volumetric radiance field approaches, such as NeRF. While effective, these methods are ...">

    <meta content="2025F, UCLA CS163 Course Projects" property="og:site_name">
    
        <meta content="Exploring Modern Novel View Generation Methods" property="og:title">
    
    
        <meta content="article" property="og:type">
    
    
        <meta content="[Project Tack] Historically, novel view synthesis (NVS) has relied on volumetric radiance field approaches, such as NeRF. While effective, these methods are often computationally expensive to train and prohibitively slow to render for real-time applications. To address these limitations, researchers have developed new architectures that reduce computational costs while maintaining..." property="og:description">
    
    
        <meta content="/2025/12/10/team32-NovelViewAHJZ.html" property="og:url">
    
<!--
    
        <meta content="Team 32" property="article:author">
        <meta content="/about/" property="article:author">
     -->

    <!-- 
        <meta content="2025-12-10T00:00:00+00:00" property="article:published_time">
        <meta content="/about/" property="article:author">
    
    
    
        
     -->

    <link rel="shortcut icon" href="/CS163-Projects-2025Fall/assets/ucla_ico.jpg">
    <link rel="stylesheet" href="/CS163-Projects-2025Fall/assets/css/main.css">
    <link rel="canonical" href="/CS163-Projects-2025Fall/2025/12/10/team32-NovelViewAHJZ.html">

    <!-- For Latex -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

    <!-- Google Analytics -->
    <!-- <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-8161570-6', 'auto');
        ga('send', 'pageview');
    </script> -->

    <!-- For Facebook share button -->
    <!-- <div id="fb-root"></div>
    <script>
      (function(d, s, id) {
        var js, fjs = d.getElementsByTagName(s)[0];
        if (d.getElementById(id)) return;
        js = d.createElement(s); js.id = id;
        js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&version=v2.9";
        fjs.parentNode.insertBefore(js, fjs);
      }(document, 'script', 'facebook-jssdk'));
    </script> -->

    <!-- Twitter cards -->
    <!-- <meta name="twitter:site"    content="@">
    <meta name="twitter:creator" content="@UCLAdeepvision">
    <meta name="twitter:title"   content="Exploring Modern Novel View Generation Methods">

    
        <meta name="twitter:description" content="<blockquote>
  <p>[Project Tack] Historically, novel view synthesis (NVS) has relied on volumetric radiance field approaches, such as NeRF. While effective, these methods are often computationally expensive to train and prohibitively slow to render for real-time applications. To address these limitations, researchers have developed new architectures that reduce computational costs while maintaining or exceeding visual fidelity. This report examines two distinct solutions to this challenge: 3D Gaussian Splatting (3DGS) and the Large View Synthesis Model (LVSM).</p>
</blockquote>

">
    

    
        <meta name="twitter:card"  content="summary">
        <meta name="twitter:image" content="">
     -->
    <!-- end of Twitter cards -->

</head>


  <body>

    <header class="site-header" role="banner" id='header-bar'>

    <div class="wrapper">
        
        <a class="site-title" style="color:#F2A900" href="/CS163-Projects-2025Fall/">2025F, UCLA CS163 Course Projects  </a>

        <!-- <nav class="site-nav">
            <a class="page-link" href="http://lilianweng.github.io" target="_blank">&#x1f349; About</a>
        </nav> -->
        <nav class="site-nav">
            <a class="page-link" style="color:#F2A900" href="/CS163-Projects-2025Fall/about.html"> About</a>
        </nav>

        <nav class="site-nav">
            <a class="page-link" style="color:#F2A900" href="/CS163-Projects-2025Fall/archive.html"> Archive</a>
        </nav>


        <!-- <nav class="site-nav">
            <a class="page-link" style="color:#FFD100" href="/CS163-Projects-2025Fall/FAQ.html"> FAQ</a>
        </nav> -->
        <!-- <nav class="site-nav">
            <a class="page-link" href="/CS163-Projects-2025Fall/log.html">&#x231b; Log</a>
        </nav> -->


    </div>

</header>


    <!-- Back to top button -->
    <script src="/CS163-Projects-2025Fall/assets/vanilla-back-to-top.min.js"></script>
    <script>addBackToTop()</script>

    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Exploring Modern Novel View Generation Methods</h1>
    <p class="post-meta">

      <time datetime="2025-12-10T00:00:00+00:00" itemprop="datePublished">
        
        Dec 10, 2025
      </time>

      <span itemprop="author" itemscope itemtype="http://schema.org/Person">
        by <span itemprop="name">Team 32</span>
      </span>

      <!-- <span>
        
      </span> -->
      <!--
      <span class="share-buttons">
        <span class="share-button"><a class="twitter-share-button" href="https://twitter.com/share" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script></span>

        <span class="share-button"><span class="fb-like" data-href="/2025/12/10/team32-NovelViewAHJZ.html" data-layout="button_count" data-action="like" data-size="small" data-show-faces="false" data-share="true"></span></span>
      </span>
      <div style="clear: both;"/>
      -->

    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <blockquote>
  <p>[Project Tack] Historically, novel view synthesis (NVS) has relied on volumetric radiance field approaches, such as NeRF. While effective, these methods are often computationally expensive to train and prohibitively slow to render for real-time applications. To address these limitations, researchers have developed new architectures that reduce computational costs while maintaining or exceeding visual fidelity. This report examines two distinct solutions to this challenge: 3D Gaussian Splatting (3DGS) and the Large View Synthesis Model (LVSM).</p>
</blockquote>

<!--more-->

<!-- TOC start (generated with https://github.com/derlin/bitdowntoc) -->

<ul>
  <li><a href="#motivation">Motivation</a></li>
  <li><a href="#current-novel-view-generation-methodologies">Current Novel View Generation Methodologies</a>
    <ul>
      <li><a href="#3d-gaussian-splatting">3D Gaussian Splatting</a>
        <ul>
          <li><a href="#overview">Overview</a></li>
          <li><a href="#method">Method</a></li>
          <li><a href="#architecture">Architecture</a></li>
          <li><a href="#results">Results</a></li>
          <li><a href="#discussion">Discussion</a></li>
          <li><a href="#running-the-codebase">Running the Codebase</a></li>
          <li><a href="#creating-a-dataset">Creating a Dataset</a></li>
          <li><a href="#exploring-activation-functions">Exploring Activation Functions</a></li>
        </ul>
      </li>
      <li><a href="#large-view-synthesis-model-lvsm">Large View Synthesis Model (LVSM)</a>
        <ul>
          <li><a href="#overview-1">Overview</a></li>
          <li><a href="#method-1">Method</a></li>
          <li><a href="#architecture-1">Architecture</a></li>
          <li><a href="#results-1">Results</a></li>
          <li><a href="#discussion-1">Discussion</a></li>
          <li><a href="#running-the-codebase-1">Running the Codebase</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#conclusion">Conclusion</a></li>
  <li><a href="#reference">Reference</a></li>
</ul>

<!-- TOC end -->

<!--
IMAGE SYNTAX REFERENCE:
![Alt Text](/CS163-Projects-2025Fall/assets/images/team32/your_image.png)
{: style="width: 400px; max-width: 100%;"}
*Fig X. Caption for image* [citation].

TABLE SYNTAX REFERENCE:
|             | column 1    |  column 2     |
| :---        |    :----:   |          ---: |
| row1        | Text        | Text          |

FORMULA SYNTAX REFERENCE:
Block formula: $$ y = mx + b $$
Inline formula: $$y = mx + b$$
-->

<!-- ## Motivation

Historically, novel view synthesis (NVS) has relied on volumetric radiance field approaches, such as NeRF. While effective, these methods are often computationally expensive to train and prohibitively slow to render for real-time applications. To address these limitations, researchers have developed new architectures that reduce computational costs while maintaining or exceeding visual fidelity. This report examines two distinct solutions to this challenge: 3D Gaussian Splatting (3DGS) and the Large View Synthesis Model (LVSM). -->

<h2 id="current-novel-view-generation-methodologies">Current Novel View Generation Methodologies</h2>

<h3 id="3d-gaussian-splatting">3D Gaussian Splatting</h3>

<blockquote>
  <p><strong>Note:</strong> This section provides an overview of 3D Gaussian Splatting based on the original paper by Kerbl et al. [1]. All figures and methodology descriptions are derived from their work.</p>
</blockquote>

<h4 id="overview">Overview</h4>

<p>Following Radiance Field-based methods such as NeRF, researchers identified a critical bottleneck: achieving high visual quality required computationally expensive training and rendering. While high-fidelity results were possible, they were too slow for real-time applications. Conversely, methods optimized for speed often sacrificed visual detail. Before this paper, real-time, high-resolution rendering (1080p) of unbounded and complete scenes was not achievable without compromising quality. 3D Gaussian Splatting introduced three key elements that maintained state-of-the-art visual quality while enabling competitive training times and real-time novel-view synthesis.</p>

<ol>
  <li>Represent the scene with 3D Gaussians, which avoids unnecessary computation in empty space in volumetric radiance fields</li>
  <li>Perform interleaved optimization and density control to achieve an accurate representation of the scene</li>
  <li>Develop a fast visibility-aware rendering algorithm that accelerates training and allows real-time rendering</li>
</ol>

<h4 id="method">Method</h4>

<p>Given input images with known camera intrinsics and extrinsics obtained via Structure-from-Motion (SfM), 3D Gaussian Splatting constructs an explicit radiance field representation using a set of anisotropic 3D Gaussian primitives. The goal of this method is to synthesize a novel target image corresponding with a target camera pose.</p>

<p>The Gaussians are defined by a full 3D covariance matrix \(\Sigma\) in 3D space, centered at a mean point \(\mu\). The following equation defines how strongly a Gaussian contributes at a given point \(x\), based on the pixel‚Äôs distance from the mean.</p>

<p style="width: 300px; max-width: 100%;"><img src="/CS163-Projects-2025Fall/assets/images/32/3dgs_Gx.png" alt="G(x) Equation" /></p>

<p>Through the blending process, the Gaussian is multiplied by \(\alpha\). In order to project the 3D Gaussian to a 2D image for rendering, a 2D covariance matrix \(\Sigma'\) must be calculated to define the ellipse shape of the Gaussian splat in image space. \(J\) represents the Jacobian of the affine approximation of the projective transformation, while \(W\) applies the world-to-camera transform to the covariance, effectively handling the rotation of the camera extrinsics for the novel view.</p>

<p style="width: 300px; max-width: 100%;"><img src="/CS163-Projects-2025Fall/assets/images/32/3dgs_jacobian.png" alt="Sigma Prime Equation" /></p>

<p>Optimizing the covariance matrix \(\Sigma\) to obtain 3D Gaussians that represent the radiance field is the right idea. However, covariance matrices must be symmetric and positive semi-definite to have meaning in physical space, and gradient updates could easily lead to the matrix becoming invalid. Instead, by defining the matrix using a scaling matrix \(S\) and rotation matrix \(R\), the corresponding \(\Sigma\) can be found. These parameters can be trained in such a way that preserves the positive semi-definite, symmetric nature of \(\Sigma\).</p>

<p style="width: 300px; max-width: 100%;"><img src="/CS163-Projects-2025Fall/assets/images/32/3dgs_sigma_parameterized.png" alt="Sigma Decomposition" /></p>

<p>By storing both factors separately, a 3D vector \(\mathbf{s}\) for scaling and a quaternion \(\mathbf{q}\) for rotation, they can be trivially converted to their respective matrices by normalizing \(\mathbf{q}\) to obtain a valid unit quaternion. Stochastic Gradient Descent is used for optimization, with a loss function combining \(L_1\) and a D-SSIM term for photometric loss.</p>

<p style="width: 300px; max-width: 100%;"><img src="/CS163-Projects-2025Fall/assets/images/32/3dgs_loss_function.png" alt="Loss Function" /></p>

<p>A key aspect of capturing scene complexity with this method is the adaptive control of 3D Gaussians during training so the representation matches the scene by dynamically adding, splitting, and removing 3D Gaussians during training. The previously mentioned \(\alpha\) is used here to control the opacity of Gaussians and effectively measures how much a Gaussian contributes to a rendered image. When Gaussians have persistently low opacity they are pruned, which prevents wasted computation on empty space and is a key reason for the computational efficiency of this approach. On the other hand, large Gaussians are split in this step to allow for a better fit of detailed surfaces, and Gaussians with large gradients are duplicated to increase local density.</p>

<p>Finally, the key aspect of the method that allows for incredibly competitive training times and real-time rendering is the Fast Differentiable Rasterizer for Gaussians. This custom GPU rasterization is designed to efficiently render and differentiate through large numbers of anisotropic Gaussian splats, while avoiding the scalability and gradient-truncation issues of prior splatting methods. It is created with three main objectives: fast rendering and sorting of Gaussian splats, correct (or near-correct) alpha blending for anisotropic Gaussians, and unrestricted gradient flow. The key idea is to sort all Gaussian splats once per image, rather than per pixel, and then reuse this ordering during rasterization utilizing a tile-based pipeline. This key innovation allows for 3D Gaussian Splatting to be practical at scale and speed.</p>

<h4 id="architecture">Architecture</h4>

<p>As opposed to previous state-of-the-art methods such as NeRF, which utilize neural architectures built around MLPs, 3D Gaussian Splatting is an explicit geometric approach built around learnable primitives and rasterization.</p>

<p>The paper proposes a scene-level, non-neural architecture composed of three tightly coupled modules:</p>

<ol>
  <li>Explicit 3D Gaussian Scene Representation</li>
  <li>Optimization and Adaptive Density Control</li>
  <li>Fast Differentiable Tile-Based Rasterizer</li>
</ol>

<p>The expressivity is moved from neural layers into the geometric primitives of 3D Gaussians as discussed above. The main training loop and optimization is shown below.</p>

<p style="width: 700px; max-width: 100%;"><img src="/CS163-Projects-2025Fall/assets/images/32/3dgs_architecture.png" alt="3DGS Architecture" /></p>
<p><em>Fig 1. Optimization of sparse SfM point cloud to create a set of 3D Gaussians, which are tiled for the optimization strategy by rasterization [1].</em></p>

<p>The optimization starts with a sparse SfM point cloud, which is used at initialization to produce the set of initial 3D Gaussian parameters. Each SfM point provides: mean (3D position), isotropic covariance (size), opacity \(\alpha\), and color (via spherical harmonics).</p>

<p>Next, this 3D representation enters the training loop at the projection stage, where camera intrinsics and extrinsics are used as inputs along with the transform of the 3D covariance matrices to create 2D anisotropic covariance matrices. This is effectively the splatting stage of the architecture.</p>

<p>From here, the Differentiable Tile Rasterizer renders the image as described in the methodology above, efficiently creating the 2D pixel-level representation. The rendered image is then compared against the ground-truth training image, and the photometric loss (\(L_1\) + SSIM) is used to compute a gradient that is passed back for SGD.</p>

<p>Passing through the differentiable rasterizer, the gradients flow through both the projection to 3D Gaussians for parameter updates and to the Adaptive Density Control module, which uses these gradients to dynamically adjust the number of Gaussians and the spatial resolution of the representation.</p>

<h4 id="results">Results</h4>

<p>Kerbl et al. tested the model for image synthesis against previous NeRF methods.</p>

<p>The paper evaluated 3D Gaussian Splatting across a diverse set of datasets against 13 real scenes from published datasets and the synthetic Blender dataset. The scenes were chosen for different capture styles, covering both indoor and outdoor environments. Results are compared to state-of-the-art quality methods at the time (Mip-NeRF360) as well as the fastest NeRF methods (InstantNGP and Plenoxels) as benchmarks for quality and speed, respectively.</p>

<p style="width: 800px; max-width: 100%;"><img src="/CS163-Projects-2025Fall/assets/images/32/3dgs_comparison_photos.png" alt="Comparison of 3DGS to previous methods" /></p>
<p><em>Fig 2. Comparison of 3D Gaussian Splatting to previous methods and ground truth from the Mip-NeRF360 dataset [1].</em></p>

<p>The image comparisons above demonstrate that 3D Gaussian Splatting achieves comparable quality to Mip-NeRF360. Critical examples are highlighted in each image with zoom-ins or red arrows.</p>

<p style="width: 800px; max-width: 100%;"><img src="/CS163-Projects-2025Fall/assets/images/32/3dgs_results_table.png" alt="Results Table" /></p>
<p><em>Table 1. Quantitative evaluation of 3DGS (labeled ‚ÄúOurs-7k‚Äù and ‚ÄúOurs-30k‚Äù) compared to previous work, computed over three datasets. Results marked with a dagger (‚Ä†) have been directly adopted from the original paper; all others were obtained in the 3DGS paper [1].</em></p>

<p>For a more quantitative focus, the table above shows that 3D Gaussian Splatting either performs comparably to or outperforms NeRF methods in quality measures, while achieving low training times proportional to quality outputs. A critical value to note is the FPS of 3D Gaussian Splatting, which for the first time enabled real-time rendering speeds. The main drawback, aside from comparison to Plenoxels, is that 3D Gaussian Splatting is highly memory-intensive, requiring significantly more storage than NeRF methods.</p>

<h4 id="discussion">Discussion</h4>

<p>3D Gaussian Splatting (3DGS) is best understood as a shift in where radiance-field expressivity lives. At the time of the paper, NeRF-style methods were largely state-of-the-art and concentrated representation power inside neural functions, typically through MLPs. 3DGS moves the representational power to a large set of explicit, learnable primitives‚Äîanisotropic Gaussians‚Äîso that rendering can become closer to typical software rasterization of computer scenes rather than volumetric ray marching, which is much more computationally intensive and less parallelizable. This effectively removes a bottleneck that had prevented previous real-time novel view synthesis at high resolution. By rendering only the primitives that project onto the screen and compositing them efficiently, 3DGS avoids wasting computation on empty space and achieves high framerates without sacrificing radiance-field-style image formation.</p>

<p>3DGS couples this effective representation with an optimization strategy that refines the structure of the image. Beyond strict updates of Gaussian attributes, the method also adaptively changes the representation through pruning and densification of existing Gaussians. This helps improve reconstruction while avoiding wasted computation.</p>

<p>The rasterizer architecture is what makes this approach feasible, as it accelerates both training and inference while preserving differentiability and stable gradient flow. As with most performance-driven designs, the tile-based pipeline trades compute for memory: the same tiling and primitive management that enable speed also increase the storage footprint, making 3DGS substantially more memory-intensive due to the large number of stored primitives.</p>

<p>Overall, 3DGS takes a fundamentally different approach from previous methods of radiance-field-quality novel view synthesis by storing representational power in 3D Gaussian primitives and utilizing optimizations and architecture to make it feasible. This leads to a tradeoff: substantially faster rendering with competitive visual quality, but high memory costs.</p>

<h4 id="running-the-codebase">Running the Codebase</h4>

<p>We use the popular open-source implementation <a href="https://github.com/pierotofy/OpenSplat">OpenSplat</a> [3], since it includes detailed instructions for building on different OSes as well as on Colab. On MacOS, it was as simple as installing the dependencies with <code class="language-plaintext highlighter-rouge">brew</code>, cloning the repository, and running <br />
<code class="language-plaintext highlighter-rouge">cmake -DCMAKE_PREFIX_PATH=/path/to/libtorch/ .. &amp;&amp; make -j$(nproc)</code>. <br />
<code class="language-plaintext highlighter-rouge">./opensplat ../data/banana -n 2000</code> finished running in around 2 minutes and produced the expected banana model, viewed on <a href="https://antimatter15.com/splat/">https://antimatter15.com/splat/</a>.</p>

<p style="width: 400px; max-width: 100%;"><img src="/CS163-Projects-2025Fall/assets/images/32/banana.png" alt="banana" /></p>
<p><em>Fig 3. Banana splat rendered on antimatter</em></p>

<h4 id="creating-a-dataset">Creating a Dataset</h4>

<p>To explore the full Gaussian splatting pipeline, we recorded a 1-minute video on an iPhone 14 Pro walking around some objects on a table. Effort was made to minimize motion blur and capture as many reference views of the objects as possible.</p>

<p>The first step afterwards was to extract the frames from the video. <code class="language-plaintext highlighter-rouge">ffmpeg</code> worked nicely, with the following producing 173 images:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">subprocess</span><span class="p">.</span><span class="n">run</span><span class="p">([</span>
    <span class="s">"ffmpeg"</span><span class="p">,</span>
    <span class="s">"-i"</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">video</span><span class="p">),</span>
    <span class="s">"-vf"</span><span class="p">,</span> <span class="s">"fps=3,scale=iw*0.75:ih*0.75"</span><span class="p">,</span>
    <span class="s">"-q:v"</span><span class="p">,</span> <span class="s">"2"</span><span class="p">,</span> <span class="c1"># quality, 0 is highest
</span>    <span class="nb">str</span><span class="p">(</span><span class="n">out</span> <span class="o">/</span> <span class="s">"%06d.jpg"</span><span class="p">),</span>
<span class="p">],</span> <span class="n">check</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</code></pre></div></div>

<p>We then ran the extracted frames through a structure-from-motion (COLMAP) pipeline to get it ready for OpenSplat:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># feature extraction
</span><span class="n">run_command</span><span class="p">([</span>
    <span class="n">colmap_bin</span><span class="p">,</span> <span class="s">"feature_extractor"</span><span class="p">,</span>
    <span class="s">"--database_path"</span><span class="p">,</span> <span class="n">database_path</span><span class="p">,</span>
    <span class="s">"--image_path"</span><span class="p">,</span> <span class="n">input_images_dir</span><span class="p">,</span>
    <span class="s">"--ImageReader.camera_model"</span><span class="p">,</span> <span class="s">"PINHOLE"</span><span class="p">,</span> 
    <span class="s">"--ImageReader.single_camera"</span><span class="p">,</span> <span class="s">"1"</span>
<span class="p">])</span>

<span class="c1"># sequential matching
</span><span class="n">run_command</span><span class="p">([</span>
    <span class="n">colmap_bin</span><span class="p">,</span> <span class="s">"sequential_matcher"</span><span class="p">,</span>
    <span class="s">"--database_path"</span><span class="p">,</span> <span class="n">database_path</span><span class="p">,</span>
    <span class="s">"--SequentialMatching.overlap"</span><span class="p">,</span> <span class="s">"10"</span><span class="p">,</span>
    <span class="s">"--SequentialMatching.loop_detection"</span><span class="p">,</span> <span class="s">"0"</span>
<span class="p">])</span>

<span class="n">run_command</span><span class="p">([</span>
    <span class="n">colmap_bin</span><span class="p">,</span> <span class="s">"mapper"</span><span class="p">,</span>
    <span class="s">"--database_path"</span><span class="p">,</span> <span class="n">database_path</span><span class="p">,</span>
    <span class="s">"--image_path"</span><span class="p">,</span> <span class="n">input_images_dir</span><span class="p">,</span>
    <span class="s">"--output_path"</span><span class="p">,</span> <span class="n">sparse_path</span>
<span class="p">])</span>

<span class="c1"># image undistortion
</span><span class="n">run_command</span><span class="p">([</span>
    <span class="n">colmap_bin</span><span class="p">,</span> <span class="s">"image_undistorter"</span><span class="p">,</span>
    <span class="s">"--image_path"</span><span class="p">,</span> <span class="n">input_images_dir</span><span class="p">,</span>
    <span class="s">"--input_path"</span><span class="p">,</span> <span class="n">sparse_path</span> <span class="o">/</span> <span class="s">"0"</span><span class="p">,</span>
    <span class="s">"--output_path"</span><span class="p">,</span> <span class="n">output_path</span><span class="p">,</span>
    <span class="s">"--output_type"</span><span class="p">,</span> <span class="s">"COLMAP"</span><span class="p">,</span>
    <span class="s">"--max_image_size"</span><span class="p">,</span> <span class="s">"2000"</span>
<span class="p">])</span>
</code></pre></div></div>

<p>Much debugging later, we were able to get a passable reconstruction of our video.</p>

<p style="width: 400px; max-width: 100%;"><img src="/CS163-Projects-2025Fall/assets/images/32/pipeline.gif" alt="pipeline" /></p>
<p><em>Fig 4. Splat of a team member‚Äôs dining table after frame extraction, SfM, and OpenSplat</em></p>

<h4 id="exploring-activation-functions">Exploring Activation Functions</h4>
<p>The paper applies a sigmoid activation to per-Gaussian opacity (Œ±) to constrain it in the [0, 1) range and an exponential activation to the covariance scale parameters in the name of smooth gradients. We investigate Softplus as an alternative covariance scale activation choice and evaluate its impact on reconstruction quality.</p>

<p>In Gaussian splatting, the covariance parameters must remain positive to ensure valid Gaussians. The paper enforces this constraint by applying an exponential activation; as a result, the magnitude of the gradient update applied to the scale parameters is directly proportional to the physical size of the Gaussian. This introduces an inductive bias where large Gaussians, typically representing background elements or low-frequency geometry, exhibit high volatility during optimization.</p>

<p>To explore this effect, we replace the exponential activation with the softplus function: <code class="language-plaintext highlighter-rouge">Softplus(p) = ln(1+exp(p))</code>. The gradient of this activation with respect to the parameter p is the sigmoid function <code class="language-plaintext highlighter-rouge">exp(p) / (1 + exp(p))</code>. As p approaches infinity, the gradient saturates at 1. Unlike the exponential function, Softplus essentially imposes a linear update rule for large Gaussians. Using Softplus activation for covariance scale, we expect to see more stability in large features during optimization.</p>

<p><img src="/CS163-Projects-2025Fall/assets/images/32/comparison1.gif" alt="exp1" style="width: 800px; max-width: 100%;" />
<em>Fig 5. Comparison of Exp and Softplus activation functions over 7000 iterations, view 1</em></p>

<p><img src="/CS163-Projects-2025Fall/assets/images/32/comparison2.gif" alt="exp1" style="width: 800px; max-width: 100%;" />
<em>Fig 6. Comparison of Exp and Softplus activation functions over 7000 iterations, view 2</em></p>

<p>Both models reconstruct the overall scene fairly well, but there are a few noticeable differences. Softplus more accurately one table corner, whereas the exponential activation leaves it somewhat blurry. Softplus also renders the diagonal shadow cast by the rear box more sharply in the first view, aligning more closely with the ground truth images. While not the difference in large Gaussians that we expected, this behavior is still nonetheless interesting.</p>

<p>A possible explanation is related to covariance stability: the exponential activation causes Gaussians to expand and contract aggressively, relying on later density control to correct their scale. Compared with the smoother, more stable behavior of softplus, this dynamic may make it harder for exp to resolve thin structures like table edges or shadows within 7,000 iterations.</p>

<p>These results are thus suggestive rather than definitive. Evaluating on a higher-quality dataset (i.e. not from a self-captured iPhone camera) and running for the recommended 30,000 iterations would help determine whether the observed advantages persist or simply reflect statistical noise.</p>

<h3 id="large-view-synthesis-model-lvsm">Large View Synthesis Model (LVSM)</h3>

<blockquote>
  <p><strong>Note:</strong> This section provides an overview of the Large View Synthesis Model based on the original paper by Jin et al. [2]. All figures and methodology descriptions are derived from their work.</p>
</blockquote>

<h4 id="overview-1">Overview</h4>

<p>Despite advances such as 3D Gaussian Splatting and many variants, existing models prior to the Large View Synthesis Model (LVSM) are encoded with 3D inductive bias (assumptions that are built in about how the 3D world is structured). For example, assumptions that use triangle meshes, NeRF volumetric fields, and 3D Gaussians all encode biases about how the world is a 3D scene and images are projections of that scene. While 3D inductive bias is  important to making learning feasible, it can be seen as a bottleneck for data-driven 3D understanding, which led to researchers \(\textbf{aiming to minimize 3D inductive biases}\) with a data-driven approach using LVSM [2]. Additionally, these prior models are trained per scene while the decoder-only LVSM is able to perform zero shot generalization, allowing it to quickly generate novel views of a specific scene without pre-training.</p>

<h4 id="method-1">Method</h4>

<p>Given \(N\) sparse input images with known camera poses and intrinsics, LVSM synthesizes a target image \(I_t\) under novel target camera extrinsics and intrinsics. For each input view, pixel-wise Pl√ºcker ray embeddings \(P_i \in \mathbb{R}^{H \times W \times 6}\) are computed from the camera parameters and patchified together with the corresponding RGB images. Each image‚Äìray patch is concatenated and projected into a latent token via</p>

\[x_{ij} = \mathrm{Linear}_{\text{input}}([I_{ij}, P_{ij}]) \in \mathbb{R}^d,\]

<p>forming a sequence of geometry-aware input tokens.</p>

<p>The target camera is represented analogously by computing its Pl√ºcker ray embeddings which are then patchified and mapped into patch-wise query tokens</p>

\[q_j = \mathrm{Linear}_{\text{target}}(P^t_j) \in \mathbb{R}^d.\]

<p>A transformer model \(M\) conditions the target query tokens on the full set of input tokens to synthesize the novel view:</p>

\[y_1, \ldots, y_{\ell_q} = M(q_1, \ldots, q_{\ell_q} \mid x_1, \ldots, x_{\ell_x}),\]

<p>where each output token \(y_j\) encodes the appearance of the \(j\)-th target patch. The output tokens are decoded into RGB patches using a linear projection followed by a sigmoid activation,</p>

\[\widehat{I}^t_j = \mathrm{Sigmoid}(\mathrm{Linear}_{\text{out}}(y_j)),\]

<p>and the predicted patches are reshaped and assembled to form the synthesized novel view \(\widehat{I}_t\).</p>

<p>\(\textbf{Loss}\): The model is trained end-to-end using photometric novel view rendering losses:</p>

\[L = \mathrm{MSE}(\widehat{I}^t, I^t) + \lambda \cdot \mathrm{Perceptual}(\widehat{I}^t, I^t),\]

<p>where \(\lambda\) balances the pixel-wise and perceptual reconstruction terms.</p>

<h4 id="architecture-1">Architecture</h4>

<p>The paper introduces the Large View Synthesis Model (LVSM), ‚Äúa novel transformer-based framework that synthesizes novel-view images from posed sparse-view inputs without predefined rendering equations or 3D structures‚Ä¶‚Äù. The paper also introduces two new architectures using this framework.</p>

<p>The first is an \(\textbf{encoder-decoder LVSM}\). It consists of an encoder, which takes in image tokens and encodes them into a fixed number of 1D latent tokens. This functions as the learned scene representation, which is used to decode novel-view images from. The second is a \(\textbf{decoder-only LVSM}\), which directly takes images and creates novel-view outputs. There is no scene representation in this model. The model‚Äôs learning of a direct mapping makes it more scalable, and can use many images to inform the mapping learned. Both, with no assumptions about the 3D world and how it is rendered, are solely data-based and achieve superior quality to existing models, even with reduced computational resources.</p>

<p style="width: 700px; max-width: 100%;"><img src="/CS163-Projects-2025Fall/assets/images/32/lvsm_architecture.png" alt="LVSM Architecture" /></p>
<p><em>Fig 7. LVSM architectures: (a) Encoder-Decoder LVSM and (b) Decoder-Only LVSM [2].</em></p>

<h4 id="results-1">Results</h4>

<p>Jin et al. evaluated LVSM across multiple datasets against previous state-of-the-art methods for both object-level and scene-level novel view synthesis. Here are the quantitative results:</p>

<p style="width: 800px; max-width: 100%;"><img src="/CS163-Projects-2025Fall/assets/images/32/lvsm_comparison_table.png" alt="LVSM Comparison Table" /></p>
<p><em>Table 2. Quantitative comparisons on object-level (left) and scene-level (right) view synthesis. Table taken from LVSM paper [2].</em></p>

<p>For object level testing, they used the Objaverse dataset to train the LVSM. Then, they tested on two object-level datasets, Google Scanned Objects (GSO) and Amazon Berkeley Objects (ABO). Based on the results, the 512-res decoder achieves a 3 dB and 2.8 dB PSNR (Peak Signal-to-Noise Ratio) against the best prior method GS-LRM (which uses 3D Gaussian splatting) and the 256-res decoder only LVSM performs a lot better than Large Multi-view Gaussian Models and GS-LRM. The results show that removing the 3D inductive bias is effective. A strong performance on the ABO dataset also suggests that the model can handle challenging materials difficult for current handcrafted 3D representations.</p>

<p>For scene level testing, they compared the results of LVSM with pixelNeRF, GPNR, pixelSplat, MVSplat, and GS-LRM. The LVSM shows a 1.6 dB PSNR gain against the best prior work GS-LRM, and the improved performance can be visualized in the below image where the LVSM has better performance on thin structures and specular materials.</p>

<p style="width: 800px; max-width: 100%;"><img src="/CS163-Projects-2025Fall/assets/images/32/lvsm_object_comparison.png" alt="LVSM Object Level Comparison" /></p>
<p><em>Fig 8. Qualitative comparison for object level testing [2].</em></p>

<p style="width: 800px; max-width: 100%;"><img src="/CS163-Projects-2025Fall/assets/images/32/lvsm_scene_comparison.png" alt="LVSM Scene Level Comparison" /></p>
<p><em>Fig 9. Qualitative comparison on the RealEstate10K dataset for scene level testing [2].</em></p>

<h4 id="discussion-1">Discussion</h4>

<p>The decoder-only model shows better performance with more input views, which shows the model is scalable at test time. On the other hand, the encoder-decoder model shows a performance drop with more input views, suggesting the intermediate representation inhibits performance when trying to compress input information. With only one input, however, the performance is competitive. The improvement in performance validates this data-driven approach, with the goal of minimizing 3D inductive bias.</p>

<p>The decoder-only model, while able to work with many images and can scale well, falls short due to the same property that makes it notable. The direct mapping from input image to novel view means linear increase in image tokens and quadratic growth in complexity. The encoder-decoder model, on the other hand, shows consistent rendering speed as there is always a fixed length set of 1D latent tokens, regardless of the number of input images.</p>

<p>Overall, the LVSM bypasses 3D representations, minimizing 3D inductive bias by using a data-driven approach, and demonstrates an improvement in performance across a variety of benchmarks.</p>

<h4 id="running-the-codebase-1">Running the Codebase</h4>

<p>Using the paper‚Äôs <a href="https://github.com/haian-jin/LVSM">Github</a> repository, we tried running the LVSM ourselves within Google Colab, modifying the code to suit the Colab environment. However, we ran into a few issues with Colab package installation, outdated NumPy code, and related dependency conflicts. In the end, we ran the inference step on 30 inputted images, but the output rendered view consisting of the synthesized views turned out to be a lot blurrier than expected. Some possibilities include sparse inputs, incorrect COLMAP generated images, and low resolution outputs.</p>

<p>Here is the rendered video output for a scene containing a long desk at the library. As you can see, the video shows blurriness as it transitions from one input image to the next input image while attempting to synthesize novel views. <a href="https://drive.google.com/file/d/1P8BDGMR9Ng-7UjQemSg4WXGn3MvCJdV3/view?usp=sharing">Video Link</a></p>

<p>To view the Colab notebook we used, please refer to this <a href="https://colab.research.google.com/drive/1Q5p3yM5bTx4vbtvFubqhtllFUuTv5DDu?usp=sharing">link</a>.</p>

<hr />

<h2 id="conclusion">Conclusion</h2>

<p>The exploration of 3D Gaussian Splatting and the Large View Synthesis Model shows a variety of approaches in novel-view synthesis, from geometry-based approaches to data-driven paradigms. 3D Gaussian Splatting demonstrates that explicit representations using Gaussians can achieve real-time performance and photorealistic quality through efficient rendering and adaptive optimization but at a high memory cost. LVSM challenges the need for strong 3D inductive biases, achieving competitive results by leveraging transformer architectures and large-scale training for generalizable view synthesis. Together, these approaches illustrate two distinct paths toward faster, more flexible, and increasingly general 3D scene understanding.</p>

<hr />

<h2 id="reference">Reference</h2>

<p>[1] Kerbl, Bernhard, et al. ‚Äú3D Gaussian Splatting for Real-Time Radiance Field Rendering.‚Äù <em>ACM Transactions on Graphics (SIGGRAPH)</em>, vol. 42, no. 4, 2023.</p>

<p>[2] Jin, Haian, et al. ‚ÄúLVSM: A Large View Synthesis Model with Minimal 3D Inductive Bias.‚Äù arXiv.org, 2 Apr. 2025, arxiv.org/abs/2410.17242.</p>

<p>[3] Pierotofy. ‚ÄúPierotofy/OpenSplat: Production-Grade 3d Gaussian Splatting with CPU/GPU Support for Windows, Mac and Linux üöÄ.‚Äù GitHub, 2024, github.com/pierotofy/OpenSplat.</p>

<hr />

  </div>


  <!-- <div class="page-navigation">
    
      <a class="prev" href="/CS163-Projects-2025Fall/2025/12/07/team28-camera-pose-estimation.html">&larr; Camera Pose Estimation</a>
    

    <!-- 
      <a class="next" href="/CS163-Projects-2025Fall/2025/12/12/team31-human-pose-estimation.html">Human Pose Estimation &rarr;</a>
     -->


  <!--comment-->
  
    <div id="disqus_thread"></div>
<script>
    /**
    *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
    *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables    */
    /*
    var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */
    (function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = 'https://https-ucladeepvision-github-io.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

</article>

      </div>
    </main>

    <div style="clear: both;" />
<footer class="site-footer">
    2024 &copy; by UCLAdeepvision. All Rights Reserved. Built by <a href="https://jekyllrb.com/"
        target="_blank">Jekyll</a>

    <!-- <p>
        <a href="/CS163-Projects-2025Fall/feed.xml" target="_blank">
            <img src="/CS163-Projects-2025Fall/assets/images/logo_rss.png" />
        </a>
        <a href="https://scholar.google.com/citations?user=dCa-pW8AAAAJ&hl=en&oi=ao" target="_blank">
            <img src="/CS163-Projects-2025Fall/assets/images/logo_scholar.png" />
        </a>
        <a href="https://github.com/lilianweng" target="_blank">
            <img src="/CS163-Projects-2025Fall/assets/images/logo_github.png" />
        </a>
    </p> -->
</footer>

  </body>

</html>
