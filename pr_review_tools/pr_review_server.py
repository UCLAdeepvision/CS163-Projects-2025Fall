#!/usr/bin/env python3
"""
PR Review Web Interface - äº¤äº’å¼PRå®¡æŸ¥å·¥å…·
åœ¨æµè§ˆå™¨ä¸­å®¡æŸ¥å’Œåˆå¹¶Pull Request
"""

from flask import Flask, render_template, jsonify, request
import json
import subprocess
import threading
import time
import os
import signal
import sys
import atexit

# è·å–é¡¹ç›®æ ¹ç›®å½•ï¼ˆä¸Šä¸€çº§ç›®å½•ï¼‰
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
PROJECT_ROOT = os.path.dirname(SCRIPT_DIR)
PR_DATA_FILE = os.path.join(SCRIPT_DIR, 'pr_data.json')

app = Flask(__name__)

# å…¨å±€çŠ¶æ€
current_state = {
    'current_pr': None,
    'temp_branch': None,
    'original_branch': None,
    'docker_running': False,
    'preview_url': 'http://localhost:4000/CS163-Projects-2025Fall/',
    'status': 'idle',
    'message': '',
    'prs': [],
    'stats': {
        'total': 0,
        'reviewed': 0,
        'accepted': 0,
        'skipped': 0
    },
    'file_changes': {
        'accepted': [],
        'rejected': [],
        'edited': []
    }
}

def run_command(cmd, capture=True, check=True):
    """è¿è¡Œshellå‘½ä»¤ï¼ˆåœ¨é¡¹ç›®æ ¹ç›®å½•æ‰§è¡Œï¼‰"""
    try:
        if capture:
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True, check=check, timeout=30, cwd=PROJECT_ROOT)
            return {'success': True, 'output': result.stdout.strip(), 'error': ''}
        else:
            subprocess.run(cmd, shell=True, check=check, timeout=30, cwd=PROJECT_ROOT)
            return {'success': True, 'output': '', 'error': ''}
    except subprocess.CalledProcessError as e:
        return {'success': False, 'output': '', 'error': e.stderr if capture else str(e)}
    except subprocess.TimeoutExpired:
        return {'success': False, 'output': '', 'error': 'Command timeout'}
    except Exception as e:
        return {'success': False, 'output': '', 'error': str(e)}

def load_pull_requests():
    """åŠ è½½PRåˆ—è¡¨"""
    try:
        # å…ˆå°è¯•ä»æ–‡ä»¶åŠ è½½
        if os.path.exists(PR_DATA_FILE):
            with open(PR_DATA_FILE, 'r') as f:
                return json.load(f)
    except:
        pass
    
    # ä»GitHubè·å–
    result = run_command('curl -s "https://api.github.com/repos/UCLAdeepvision/CS163-Projects-2025Fall/pulls?state=open&per_page=100"', capture=True, check=False)
    if result['success'] and result['output']:
        try:
            prs = json.loads(result['output'])
            # ä¿å­˜åˆ°æ–‡ä»¶
            with open(PR_DATA_FILE, 'w') as f:
                json.dump(prs, f, indent=2)
            return prs
        except:
            pass
    return []

def get_current_branch():
    """è·å–å½“å‰åˆ†æ”¯"""
    result = run_command("git branch --show-current", capture=True, check=False)
    return result['output'] if result['success'] else 'main'

def post_github_comment(pr_number, comment_body):
    """å‘å¸ƒè¯„è®ºåˆ°GitHub PR"""
    try:
        import json
        comment_json = json.dumps({'body': comment_body})
        # ä½¿ç”¨curlå‘é€è¯„è®ºï¼ˆéœ€è¦GitHub tokenï¼‰
        # å…ˆæ£€æŸ¥æ˜¯å¦æœ‰GITHUB_TOKENç¯å¢ƒå˜é‡
        import os
        token = os.environ.get('GITHUB_TOKEN', '')
        
        if not token:
            print("Warning: GITHUB_TOKEN not set, skipping comment")
            return False
        
        cmd = f'''curl -X POST \
            -H "Authorization: token {token}" \
            -H "Accept: application/vnd.github.v3+json" \
            https://api.github.com/repos/UCLAdeepvision/CS163-Projects-2025Fall/issues/{pr_number}/comments \
            -d '{comment_json}' '''
        
        result = run_command(cmd, capture=True, check=False)
        return result['success']
    except Exception as e:
        print(f"Failed to post comment: {e}")
        return False

def generate_review_comment(accepted_files, rejected_files, edited_files=None):
    """ç”Ÿæˆå®¡æŸ¥è¯„è®ºå†…å®¹ (è‹±æ–‡)"""
    comment = "## ğŸ¤– Automated Review Report\n\n"
    
    if accepted_files:
        comment += f"### âœ… Accepted Files ({len(accepted_files)})\n"
        for f in accepted_files[:20]:  # æœ€å¤šæ˜¾ç¤º20ä¸ª
            comment += f"- `{f}`\n"
        if len(accepted_files) > 20:
            comment += f"- ... and {len(accepted_files) - 20} more files\n"
        comment += "\n"
    
    if rejected_files:
        comment += f"### âŒ Rejected Files ({len(rejected_files)})\n"
        comment += "_These files are not in the allowed directories (assets/, _posts/)_\n\n"
        for f in rejected_files[:20]:
            comment += f"- `{f}`\n"
        if len(rejected_files) > 20:
            comment += f"- ... and {len(rejected_files) - 20} more files\n"
        comment += "\n"
    
    if edited_files:
        comment += f"### âœï¸ Edited Files ({len(edited_files)})\n"
        comment += "_These files were modified during the review process_\n\n"
        for f in edited_files:
            comment += f"- `{f}`\n"
        comment += "\n"
    
    comment += "---\n"
    comment += "_This comment was automatically generated by the review tool_"
    
    return comment

def start_docker_background():
    """åœ¨åå°å¯åŠ¨Docker"""
    current_state['status'] = 'starting_docker'
    current_state['message'] = 'æ­£åœ¨å¯åŠ¨Dockeré¢„è§ˆ...'
    
    # å…ˆåœæ­¢ç°æœ‰å®¹å™¨
    run_command("docker compose down", capture=False, check=False)
    time.sleep(2)
    
    # å¯åŠ¨å®¹å™¨ï¼ˆä¸ç”¨buildï¼‰
    result = run_command("docker compose up -d", capture=False, check=False)
    
    if result['success']:
        current_state['docker_running'] = True
        current_state['status'] = 'docker_ready'
        current_state['message'] = f'Dockerå·²å¯åŠ¨ï¼è¯·è®¿é—®: {current_state["preview_url"]}'
    else:
        current_state['docker_running'] = False
        current_state['status'] = 'docker_error'
        current_state['message'] = f'Dockerå¯åŠ¨å¤±è´¥: {result["error"]}'

def stop_docker():
    """åœæ­¢Docker"""
    run_command("docker compose down", capture=False, check=False)
    current_state['docker_running'] = False
    current_state['message'] = 'Dockerå·²åœæ­¢'

def cleanup_branch():
    """æ¸…ç†ä¸´æ—¶åˆ†æ”¯"""
    if current_state['temp_branch']:
        # æ£€æŸ¥æ˜¯å¦æœ‰æœªæäº¤çš„æ›´æ”¹
        run_command("git reset --hard", capture=False, check=False)
        
        # æ¸…ç†æœªè·Ÿè¸ªçš„æ–‡ä»¶ï¼ˆ_site/ç­‰ï¼‰
        run_command("rm -rf _site/", capture=False, check=False)
        run_command("git clean -fd", capture=False, check=False)
        
        # è¿”å›åŸå§‹åˆ†æ”¯
        if current_state['original_branch']:
            run_command(f"git checkout {current_state['original_branch']}", capture=False, check=False)
        
        # åˆ é™¤ä¸´æ—¶åˆ†æ”¯
        run_command(f"git branch -D {current_state['temp_branch']}", capture=False, check=False)
        
        current_state['temp_branch'] = None

def cleanup_on_exit():
    """é€€å‡ºæ—¶çš„æ¸…ç†å‡½æ•°"""
    print("\n\næ”¶åˆ°é€€å‡ºä¿¡å·ï¼Œæ­£åœ¨æ¸…ç†...")
    
    # åœæ­¢Docker
    print("åœæ­¢Dockerå®¹å™¨...")
    stop_docker()
    
    # æ¸…ç†GitçŠ¶æ€
    try:
        current_branch = get_current_branch()
        print(f"å½“å‰åˆ†æ”¯: {current_branch}")
        
        # å¦‚æœåœ¨reviewåˆ†æ”¯ä¸Šï¼Œéœ€è¦æ¸…ç†
        if current_branch and current_branch.startswith('review-pr-'):
            print(f"æ£€æµ‹åˆ°ä¸´æ—¶åˆ†æ”¯: {current_branch}")
            
            # é‡ç½®ä»»ä½•æœªæäº¤çš„æ›´æ”¹
            print("é‡ç½®æœªæäº¤çš„æ›´æ”¹...")
            run_command("git reset --hard", capture=False, check=False)
            
            # æ¸…ç†æœªè·Ÿè¸ªçš„æ–‡ä»¶
            print("æ¸…ç†æœªè·Ÿè¸ªçš„æ–‡ä»¶...")
            run_command("rm -rf _site/", capture=False, check=False)
            run_command("git clean -fd", capture=False, check=False)
            
            # è¿”å›mainåˆ†æ”¯
            print("è¿”å›mainåˆ†æ”¯...")
            result = run_command("git checkout main", capture=False, check=False)
            
            if result['success']:
                print(f"âœ“ å·²åˆ‡æ¢åˆ°mainåˆ†æ”¯")
                
                # åˆ é™¤ä¸´æ—¶åˆ†æ”¯
                print(f"åˆ é™¤ä¸´æ—¶åˆ†æ”¯: {current_branch}")
                run_command(f"git branch -D {current_branch}", capture=False, check=False)
                print(f"âœ“ å·²åˆ é™¤ä¸´æ—¶åˆ†æ”¯")
            else:
                print(f"âš ï¸  åˆ‡æ¢åˆ†æ”¯å¤±è´¥ï¼Œå¯èƒ½éœ€è¦æ‰‹åŠ¨æ¸…ç†")
                print(f"è¯·æ‰‹åŠ¨è¿è¡Œ: git checkout main && git branch -D {current_branch}")
        
        # å¦‚æœæœ‰è®°å½•çš„ä¸´æ—¶åˆ†æ”¯ï¼ˆé˜²æ­¢çŠ¶æ€ä¸ä¸€è‡´ï¼‰
        if current_state['temp_branch'] and current_state['temp_branch'] != current_branch:
            print(f"æ¸…ç†è®°å½•çš„ä¸´æ—¶åˆ†æ”¯: {current_state['temp_branch']}")
            run_command(f"git branch -D {current_state['temp_branch']}", capture=False, check=False)
    
    except Exception as e:
        print(f"æ¸…ç†æ—¶å‡ºé”™: {e}")
        print("å¯èƒ½éœ€è¦æ‰‹åŠ¨æ¸…ç†GitçŠ¶æ€")
    
    print("\nâœ“ æ¸…ç†å®Œæˆ")
    print("å†è§ï¼ğŸ‘‹\n")

def signal_handler(sig, frame):
    """å¤„ç†Ctrl+Cä¿¡å·"""
    cleanup_on_exit()
    sys.exit(0)

@app.route('/')
def index():
    """ä¸»é¡µ"""
    return render_template('pr_review.html')

@app.route('/api/prs')
def get_prs():
    """è·å–PRåˆ—è¡¨"""
    if not current_state['prs']:
        current_state['prs'] = load_pull_requests()
        current_state['stats']['total'] = len(current_state['prs'])
    
    prs_data = []
    for i, pr in enumerate(current_state['prs'], 1):
        prs_data.append({
            'index': i,
            'number': pr['number'],
            'title': pr['title'],
            'author': pr['user']['login'],
            'branch': f"{pr['head']['label']} -> {pr['base']['ref']}",
            'created_at': pr['created_at'],
            'url': pr['html_url']
        })
    
    return jsonify({
        'success': True,
        'prs': prs_data,
        'stats': current_state['stats']
    })

@app.route('/api/status')
def get_status():
    """è·å–å½“å‰çŠ¶æ€"""
    return jsonify({
        'success': True,
        'status': current_state['status'],
        'message': current_state['message'],
        'docker_running': current_state['docker_running'],
        'preview_url': current_state['preview_url'],
        'current_pr': current_state['current_pr'],
        'stats': current_state['stats']
    })

@app.route('/api/prepare_pr', methods=['POST'])
def prepare_pr():
    """å‡†å¤‡å®¡æŸ¥PR"""
    data = request.json
    pr_index = data.get('index', 0) - 1
    
    if pr_index < 0 or pr_index >= len(current_state['prs']):
        return jsonify({'success': False, 'error': 'Invalid PR index'})
    
    pr = current_state['prs'][pr_index]
    current_state['current_pr'] = {
        'index': pr_index + 1,
        'number': pr['number'],
        'title': pr['title'],
        'author': pr['user']['login'],
        'branch': f"{pr['head']['label']} -> {pr['base']['ref']}"
    }
    
    current_state['status'] = 'preparing'
    current_state['message'] = f'æ­£åœ¨å‡†å¤‡PR #{pr["number"]}...'
    
    # åœ¨åå°çº¿ç¨‹ä¸­æ‰§è¡Œå‡†å¤‡å·¥ä½œ
    def prepare_thread():
        try:
            pr_number = pr['number']
            pr_head_ref = pr['head']['ref']
            pr_head_repo = pr['head']['repo']
            temp_branch = f"review-pr-{pr_number}"
            
            current_state['temp_branch'] = temp_branch
            current_state['original_branch'] = get_current_branch()
            
            # 0. æ¸…ç†å¯èƒ½æ®‹ç•™çš„æœªè·Ÿè¸ªæ–‡ä»¶
            current_state['message'] = 'æ¸…ç†å·¥ä½œåŒº...'
            # æ¸…ç† _site/ ç›®å½•ï¼ˆJekyllç”Ÿæˆçš„ï¼Œä¸åº”è¯¥æäº¤ï¼‰
            run_command("rm -rf _site/", capture=False, check=False)
            # æ¸…ç†å¯èƒ½æ®‹ç•™çš„ Gemfile.lockï¼ˆå¦‚æœæ˜¯æœªè·Ÿè¸ªçš„ï¼‰
            run_command("git clean -fd", capture=False, check=False)
            
            # 1. åˆ›å»ºä¸´æ—¶åˆ†æ”¯ï¼ˆå¦‚æœå·²å­˜åœ¨åˆ™å…ˆåˆ é™¤ï¼‰
            current_state['message'] = 'åˆ›å»ºä¸´æ—¶åˆ†æ”¯...'
            # æ£€æŸ¥åˆ†æ”¯æ˜¯å¦å­˜åœ¨
            check_branch = run_command(f"git rev-parse --verify {temp_branch}", capture=True, check=False)
            if check_branch['success']:
                # åˆ†æ”¯å·²å­˜åœ¨ï¼Œå…ˆåˆ é™¤
                run_command(f"git branch -D {temp_branch}", capture=False, check=False)
            
            result = run_command(f"git checkout -b {temp_branch}", capture=False, check=False)
            if not result['success']:
                current_state['status'] = 'error'
                current_state['message'] = f'åˆ›å»ºåˆ†æ”¯å¤±è´¥: {result["error"]}'
                return
            
            # 2. æ›´æ–°main
            current_state['message'] = 'æ›´æ–°mainåˆ†æ”¯...'
            run_command(f"git fetch origin main", capture=False, check=False)
            
            # 3. åˆå¹¶main
            current_state['message'] = 'åˆå¹¶mainåˆ°ä¸´æ—¶åˆ†æ”¯...'
            result = run_command(f"git merge origin/main --no-edit", capture=False, check=False)
            
            # 4. è·å–å¹¶åˆå¹¶PR
            current_state['message'] = f'è·å–å¹¶åˆå¹¶PR #{pr_number}...'
            if pr_head_repo:
                head_repo_url = pr_head_repo['clone_url']
                run_command(f"git fetch {head_repo_url} {pr_head_ref}", capture=False, check=False)
            else:
                run_command(f"git fetch origin pull/{pr_number}/head", capture=False, check=False)
            
            result = run_command(f"git merge FETCH_HEAD --no-edit", capture=False, check=False)
            
            if not result['success']:
                # æ£€æŸ¥æ˜¯å¦æœ‰å†²çª
                conflict_check = run_command("git diff --name-only --diff-filter=U", capture=True, check=False)
                if conflict_check['success'] and conflict_check['output']:
                    current_state['status'] = 'conflict'
                    current_state['message'] = f'åˆå¹¶å†²çª: {conflict_check["output"]}'
                    current_state['stats']['skipped'] += 1
                    current_state['stats']['reviewed'] += 1
                    cleanup_branch()
                    current_state['current_pr'] = None
                    return
            
            # æ£€æŸ¥ä¿®æ”¹çš„æ–‡ä»¶ï¼Œåªä¿ç•™ assets/ å’Œ _posts/ ç›®å½•ä¸‹çš„ä¿®æ”¹
            current_state['message'] = 'æ£€æŸ¥å¹¶è¿‡æ»¤ä¿®æ”¹çš„æ–‡ä»¶...'
            changed_files = run_command("git diff --name-only origin/main", capture=True, check=False)
            if changed_files['success'] and changed_files['output']:
                files = changed_files['output'].split('\n')
                valid_files = []
                invalid_files = []
                
                for f in files:
                    f = f.strip()
                    if not f:
                        continue
                    if f.startswith('assets/') or f.startswith('_posts/'):
                        valid_files.append(f)
                    else:
                        invalid_files.append(f)
                
                # è®°å½•æ–‡ä»¶å˜åŒ–
                current_state['file_changes']['accepted'] = valid_files
                current_state['file_changes']['rejected'] = invalid_files
                current_state['file_changes']['edited'] = []
                
                if invalid_files:
                    # æœ‰ä¸å…è®¸çš„æ–‡ä»¶ï¼Œéœ€è¦è¿‡æ»¤
                    current_state['message'] = f'è¿‡æ»¤ä¸å…è®¸çš„æ–‡ä»¶: {len(invalid_files)} ä¸ª'
                    
                    if not valid_files:
                        # æ²¡æœ‰æœ‰æ•ˆæ–‡ä»¶ï¼Œç›´æ¥è·³è¿‡
                        current_state['status'] = 'no_valid_files'
                        current_state['message'] = f'âŒ PRä¸åŒ…å«å…è®¸çš„æ–‡ä»¶ä¿®æ”¹\nåªå…è®¸ä¿®æ”¹ assets/ å’Œ _posts/ ç›®å½•'
                        current_state['stats']['skipped'] += 1
                        current_state['stats']['reviewed'] += 1
                        cleanup_branch()
                        current_state['current_pr'] = None
                        return
                    
                    # é‡ç½®åˆ°origin/mainï¼Œç„¶ååªä¿ç•™å…è®¸çš„æ–‡ä»¶
                    run_command("git reset --hard origin/main", capture=False, check=False)
                    
                    # ä»PRè·å–å¹¶åªcheckoutå…è®¸çš„æ–‡ä»¶
                    if pr_head_repo:
                        head_repo_url = pr_head_repo['clone_url']
                        run_command(f"git fetch {head_repo_url} {pr_head_ref}", capture=False, check=False)
                    else:
                        run_command(f"git fetch origin pull/{pr_number}/head", capture=False, check=False)
                    
                    # åªcheckoutå…è®¸çš„æ–‡ä»¶
                    for vf in valid_files:
                        run_command(f"git checkout FETCH_HEAD -- {vf}", capture=False, check=False)
                    
                    # æäº¤è¿‡æ»¤åçš„ä¿®æ”¹
                    run_command("git add -A", capture=False, check=False)
                    commit_msg = f"Filtered changes from PR #{pr_number} (only assets/ and _posts/)"
                    run_command(f'git commit -m "{commit_msg}"', capture=False, check=False)
                    
                    current_state['message'] = f'âœ“ å·²è¿‡æ»¤ {len(invalid_files)} ä¸ªä¸å…è®¸çš„æ–‡ä»¶ï¼Œä¿ç•™ {len(valid_files)} ä¸ªæœ‰æ•ˆæ–‡ä»¶'
            
            # 5. å¯åŠ¨Docker
            start_docker_background()
            
        except Exception as e:
            current_state['status'] = 'error'
            current_state['message'] = f'é”™è¯¯: {str(e)}'
            cleanup_branch()
    
    thread = threading.Thread(target=prepare_thread)
    thread.daemon = True
    thread.start()
    
    return jsonify({'success': True, 'message': 'Started preparing PR'})

@app.route('/api/get_file_summary')
def get_file_summary():
    """è·å–æ–‡ä»¶å˜æ›´æ‘˜è¦"""
    return jsonify({
        'success': True,
        'accepted': len(current_state['file_changes']['accepted']),
        'rejected': len(current_state['file_changes']['rejected']),
        'edited': len(current_state['file_changes']['edited'])
    })

@app.route('/api/generate_comment')
def generate_comment_api():
    """ç”Ÿæˆè¯„è®ºå†…å®¹"""
    comment = generate_review_comment(
        current_state['file_changes']['accepted'],
        current_state['file_changes']['rejected'],
        current_state['file_changes']['edited']
    )
    return jsonify({'success': True, 'comment': comment})

@app.route('/api/check_edited_files')
def check_edited_files():
    """æ£€æŸ¥å“ªäº›æ–‡ä»¶è¢«ç¼–è¾‘äº†"""
    try:
        # ä½¿ç”¨git diffæ£€æŸ¥ä¿®æ”¹çš„æ–‡ä»¶
        result = run_command("git diff --name-only", capture=True, check=False)
        
        if result['success'] and result['output']:
            files = result['output'].strip().split('\n')
            # åªä¿ç•™acceptedçš„æ–‡ä»¶
            edited_files = [f for f in files if f in current_state['file_changes']['accepted']]
            
            # æ›´æ–°çŠ¶æ€
            current_state['file_changes']['edited'] = edited_files
            
            # è‡ªåŠ¨git addè¿™äº›æ–‡ä»¶
            for f in edited_files:
                run_command(f"git add {f}", capture=False, check=False)
            
            return jsonify({
                'success': True,
                'edited_files': edited_files
            })
        else:
            return jsonify({
                'success': True,
                'edited_files': []
            })
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e),
            'edited_files': []
        })

@app.route('/api/accept_pr', methods=['POST'])
def accept_pr():
    """æ¥å—å¹¶åˆå¹¶PR"""
    if not current_state['current_pr']:
        return jsonify({'success': False, 'error': 'No PR is being reviewed'})
    
    # è·å–è‡ªå®šä¹‰è¯„è®ºå’Œé¢å¤–è¯„è®º
    data = request.json or {}
    custom_comment = data.get('custom_comment', '').strip()
    additional_comment = data.get('additional_comment', '').strip()
    
    current_state['status'] = 'accepting'
    current_state['message'] = 'æ­£åœ¨åˆå¹¶åˆ°main...'
    
    def accept_thread():
        try:
            # åœæ­¢Docker
            stop_docker()
            time.sleep(1)
            
            pr_number = current_state['current_pr']['number']
            pr_title = current_state['current_pr']['title']
            pr_branch = current_state['current_pr']['branch']
            temp_branch = current_state['temp_branch']
            
            # åˆ‡æ¢åˆ°main
            current_state['message'] = 'åˆ‡æ¢åˆ°mainåˆ†æ”¯...'
            result = run_command("git checkout main", capture=False, check=False)
            if not result['success']:
                current_state['status'] = 'error'
                current_state['message'] = f'åˆ‡æ¢åˆ°mainå¤±è´¥: {result["error"]}'
                return
            
            # æ‹‰å–æœ€æ–°çš„main
            current_state['message'] = 'æ‹‰å–æœ€æ–°çš„main...'
            run_command("git pull origin main", capture=False, check=False)
            
            # åˆå¹¶ä¸´æ—¶åˆ†æ”¯åˆ°main
            current_state['message'] = f'åˆå¹¶PR #{pr_number}åˆ°main...'
            merge_cmd = f"git merge {temp_branch} --no-ff -m 'Merge pull request #{pr_number}\\n\\n{pr_title}'"
            result = run_command(merge_cmd, capture=False, check=False)
            
            if result['success']:
                current_state['stats']['accepted'] += 1
                current_state['stats']['reviewed'] += 1
                current_state['status'] = 'accepted'
                current_state['message'] = f'âœ“ PR #{pr_number} å·²æˆåŠŸåˆå¹¶åˆ°mainï¼è®°å¾—è¿è¡Œ git push origin main'
                
                # å‘é€GitHub comment
                current_state['message'] += '\næ­£åœ¨å‘é€å®¡æŸ¥æŠ¥å‘Š...'
                
                # ä½¿ç”¨è‡ªå®šä¹‰è¯„è®ºæˆ–è‡ªåŠ¨ç”Ÿæˆ
                if custom_comment:
                    comment_body = custom_comment
                else:
                    comment_body = generate_review_comment(
                        current_state['file_changes']['accepted'],
                        current_state['file_changes']['rejected'],
                        current_state['file_changes']['edited']
                    )
                
                # é™„åŠ é¢å¤–è¯„è®º
                if additional_comment:
                    comment_body += f"\n\n## ğŸ’¡ Additional Comments\n\n{additional_comment}"
                
                if post_github_comment(pr_number, comment_body):
                    current_state['message'] += '\nâœ“ å®¡æŸ¥æŠ¥å‘Šå·²å‘é€åˆ°GitHub'
                else:
                    current_state['message'] += '\nâš ï¸  å®¡æŸ¥æŠ¥å‘Šå‘é€å¤±è´¥ï¼ˆéœ€è¦è®¾ç½®GITHUB_TOKENï¼‰'
            else:
                current_state['status'] = 'error'
                current_state['message'] = f'åˆå¹¶å¤±è´¥: {result["error"]}'
                run_command("git merge --abort", capture=False, check=False)
            
            # æ¸…ç†
            cleanup_branch()
            current_state['current_pr'] = None
            
        except Exception as e:
            current_state['status'] = 'error'
            current_state['message'] = f'é”™è¯¯: {str(e)}'
    
    thread = threading.Thread(target=accept_thread)
    thread.daemon = True
    thread.start()
    
    return jsonify({'success': True, 'message': 'Started accepting PR'})

@app.route('/api/skip_pr', methods=['POST'])
def skip_pr():
    """è·³è¿‡PR"""
    if not current_state['current_pr']:
        return jsonify({'success': False, 'error': 'No PR is being reviewed'})
    
    pr_number = current_state['current_pr']['number']
    
    # åœæ­¢Docker
    stop_docker()
    
    # æ¸…ç†
    cleanup_branch()
    
    current_state['stats']['skipped'] += 1
    current_state['stats']['reviewed'] += 1
    current_state['status'] = 'skipped'
    current_state['message'] = f'å·²è·³è¿‡PR #{pr_number}'
    current_state['current_pr'] = None
    
    return jsonify({'success': True, 'message': 'PR skipped'})

@app.route('/api/refresh_prs', methods=['POST'])
def refresh_prs():
    """åˆ·æ–°PRåˆ—è¡¨"""
    current_state['prs'] = load_pull_requests()
    current_state['stats']['total'] = len(current_state['prs'])
    return jsonify({'success': True, 'message': 'PR list refreshed', 'count': len(current_state['prs'])})

@app.route('/api/restart_docker', methods=['POST'])
def restart_docker():
    """é‡å¯Docker"""
    stop_docker()
    time.sleep(1)
    
    thread = threading.Thread(target=start_docker_background)
    thread.daemon = True
    thread.start()
    
    return jsonify({'success': True, 'message': 'Restarting Docker'})

@app.route('/api/get_files')
def get_files():
    """è·å–å½“å‰PRçš„å¯ç¼–è¾‘æ–‡ä»¶åˆ—è¡¨"""
    if not current_state['current_pr']:
        return jsonify({'success': False, 'error': 'No PR is being reviewed'})
    
    files = current_state['file_changes']['accepted']
    return jsonify({'success': True, 'files': files})

@app.route('/api/read_file', methods=['POST'])
def read_file_content():
    """è¯»å–æ–‡ä»¶å†…å®¹"""
    data = request.json
    file_path = data.get('path', '')
    
    if not file_path:
        return jsonify({'success': False, 'error': 'No file path provided'})
    
    # å®‰å…¨æ£€æŸ¥ï¼šåªå…è®¸è¯»å–acceptedçš„æ–‡ä»¶
    if file_path not in current_state['file_changes']['accepted']:
        return jsonify({'success': False, 'error': 'File not in accepted list'})
    
    full_path = os.path.join(PROJECT_ROOT, file_path)
    try:
        with open(full_path, 'r', encoding='utf-8') as f:
            content = f.read()
        return jsonify({'success': True, 'content': content})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/save_file', methods=['POST'])
def save_file_content():
    """ä¿å­˜ç¼–è¾‘çš„æ–‡ä»¶"""
    data = request.json
    file_path = data.get('path', '')
    content = data.get('content', '')
    
    if not file_path:
        return jsonify({'success': False, 'error': 'No file path provided'})
    
    # å®‰å…¨æ£€æŸ¥ï¼šåªå…è®¸ä¿å­˜acceptedçš„æ–‡ä»¶
    if file_path not in current_state['file_changes']['accepted']:
        return jsonify({'success': False, 'error': 'File not in accepted list'})
    
    full_path = os.path.join(PROJECT_ROOT, file_path)
    try:
        with open(full_path, 'w', encoding='utf-8') as f:
            f.write(content)
        
        # æ ‡è®°ä¸ºå·²ç¼–è¾‘
        if file_path not in current_state['file_changes']['edited']:
            current_state['file_changes']['edited'].append(file_path)
        
        # æäº¤æ›´æ”¹
        run_command(f"git add {file_path}", capture=False, check=False, cwd=PROJECT_ROOT)
        
        return jsonify({'success': True, 'message': f'File {file_path} saved'})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

if __name__ == '__main__':
    # æ³¨å†Œä¿¡å·å¤„ç†å™¨
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    
    # æ³¨å†Œé€€å‡ºæ—¶çš„æ¸…ç†å‡½æ•°
    atexit.register(cleanup_on_exit)
    
    print("="*80)
    print("PR Review Web Interface")
    print("="*80)
    print("\nè¯·åœ¨æµè§ˆå™¨ä¸­è®¿é—®: http://localhost:5001")
    print("\næŒ‰ Ctrl+C åœæ­¢æœåŠ¡å™¨ï¼ˆä¼šè‡ªåŠ¨æ¸…ç†ä¸´æ—¶åˆ†æ”¯ï¼‰\n")
    
    # åŠ è½½PRåˆ—è¡¨
    current_state['prs'] = load_pull_requests()
    current_state['stats']['total'] = len(current_state['prs'])
    
    try:
        # å¯åŠ¨Flaskåº”ç”¨
        app.run(debug=False, host='0.0.0.0', port=5001, use_reloader=False)
    except KeyboardInterrupt:
        # Flaskå·²ç»æ•è·äº†Ctrl+Cï¼Œä½†æˆ‘ä»¬çš„signal_handlerä¼šå¤„ç†
        pass

