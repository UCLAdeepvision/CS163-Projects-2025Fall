<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="http://localhost:4000/CS163-Projects-2025Fall/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/CS163-Projects-2025Fall/" rel="alternate" type="text/html" /><updated>2025-12-14T08:17:29+08:00</updated><id>http://localhost:4000/CS163-Projects-2025Fall/feed.xml</id><title type="html">2025F, UCLA CS163 Course Projects</title><subtitle>Course projects for UCLA CS163, Deep Learning in Compuver Vision</subtitle><author><name>UCLAdeepvision</name></author><entry><title type="html">Self-Supervised Learning</title><link href="http://localhost:4000/CS163-Projects-2025Fall/2025/12/09/team40-projectshortname.html" rel="alternate" type="text/html" title="Self-Supervised Learning" /><published>2025-12-09T00:00:00+08:00</published><updated>2025-12-09T00:00:00+08:00</updated><id>http://localhost:4000/CS163-Projects-2025Fall/2025/12/09/team40-projectshortname</id><content type="html" xml:base="http://localhost:4000/CS163-Projects-2025Fall/2025/12/09/team40-projectshortname.html"><![CDATA[<blockquote>
  <p>Self-supervised Learning is a way for models to learn useful features without relying on labeled data. The model can create its own learning targets from the structure of the data. This method becomes popular in computer vision and many other fields because it makes use of large amounts of unlabeled data and can produce strong representations for downstream tasks. In this paper, we introduce the basic ideas behind self-supervised learning and discuss several common methods and why they are effective.</p>
</blockquote>

<!--more-->
<ul id="markdown-toc">
  <li><a href="#introduction" id="markdown-toc-introduction">Introduction</a></li>
  <li><a href="#contrastive-learning-simclr" id="markdown-toc-contrastive-learning-simclr">Contrastive Learning (SimCLR)</a>    <ul>
      <li><a href="#1-model-structure" id="markdown-toc-1-model-structure">1. Model Structure</a></li>
      <li><a href="#2-workflow" id="markdown-toc-2-workflow">2. Workflow</a></li>
      <li><a href="#3-key-findings" id="markdown-toc-3-key-findings">3. Key Findings</a></li>
    </ul>
  </li>
  <li><a href="#masked-image-modelling-mae" id="markdown-toc-masked-image-modelling-mae">Masked Image Modelling (MAE)</a>    <ul>
      <li><a href="#1-model-structure-1" id="markdown-toc-1-model-structure-1">1. Model Structure</a></li>
      <li><a href="#2-workflow-1" id="markdown-toc-2-workflow-1">2. Workflow</a></li>
      <li><a href="#3-key-findings-and-results" id="markdown-toc-3-key-findings-and-results">3. Key Findings and Results</a></li>
    </ul>
  </li>
  <li><a href="#dino-self-distillation-with-no-labels" id="markdown-toc-dino-self-distillation-with-no-labels">DINO: self-distillation with no labels</a>    <ul>
      <li><a href="#model-structure" id="markdown-toc-model-structure">Model Structure</a></li>
      <li><a href="#workflow" id="markdown-toc-workflow">Workflow</a></li>
      <li><a href="#key-findings--techniques" id="markdown-toc-key-findings--techniques">Key Findings &amp; techniques</a></li>
    </ul>
  </li>
  <li><a href="#conclusion" id="markdown-toc-conclusion">Conclusion</a></li>
  <li><a href="#reference" id="markdown-toc-reference">Reference</a></li>
</ul>

<h2 id="introduction">Introduction</h2>
<p>Deep learning is a field that learns pattern and representations from data, and many of its breakthrough have relied on supervised learning. However, supervised learning depends on massive labeled datasets, and creating these labels is often expensive, time-consuming, and requires expertise. In many real situations, most datasets are unlabeled, which makes supervised learning difficult to apply in many practical situations. Therefore, self-supervised learning was developed to address this challenge. Instead of relying on human annotations, self-supervised learning creates pretext tasks that force the model to learn meaningful structure directly from the data itself.</p>

<p>Other than self-supervised learning, semi-supervised learning is also a useful way to train a model when labeled data is not sufficient. It uses both labeled and unlabeled data during training. In general, a semi-supervised learning workflow starts by training the model on the labeled data and then using the model’s own predictions to guide learning on the unlabeled data. Popular semi-supervised approaches include pseudo-labeling and consistency regularization. In practice, semi-supervised learning is preferred when at least some labels exist and we want to boost performance when adding unlabeled data. Self-supervised learning, on the other hand, is more suitable when obtaining labels is very difficult or expensive. In this paper, we will focus on several popular methods in self-supervised learning and discuss why they have become strong alternatives to fully supervised and semi-supervised approaches.</p>

<table>
  <thead>
    <tr>
      <th>Learning Method</th>
      <th>Training Data</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Supervised Learning</td>
      <td>Fully labeled datasets</td>
    </tr>
    <tr>
      <td>Self-Supervised Learning</td>
      <td>Large-scale unlabeled datasets</td>
    </tr>
    <tr>
      <td>Semi-Supervised Learning</td>
      <td>Limited labeled data combined with large amounts of unlabeled data</td>
    </tr>
  </tbody>
</table>

<h2 id="contrastive-learning-simclr">Contrastive Learning (SimCLR)</h2>
<p>SimCLR is a self-supervised learning method built on contrastive representation learning. Its core idea is to make representations of different augmented views of the same image (positive pair) closer while representations of different images (negative pair) far apart[1].</p>
<h3 id="1-model-structure">1. Model Structure</h3>

<p><img src="/CS163-Projects-2025Fall/assets/images/team40/simclr.png" alt="SimCLR Pipeline" />
<em>Fig 1. SimCLR: Overview of SimCLR Framework</em> [1].</p>

<h4 id="encoder">Encoder</h4>
<p>A base encoder extracts features from each augmented view. This encoder learns meaningful visual representations without labels.</p>

<h4 id="projection-head">Projection Head</h4>
<p>The encoder output is passed into a small MLP projection head:</p>

\[z = \text{MLP}(h)\]

<p>This projection improves the quality of contrastive learning; the encoder’s representation $h$ is used for downstream tasks.</p>

<h4 id="nt-xent-contrastive-loss">NT-Xent Contrastive loss</h4>
<p>SimCLR uses the NT-Xent (Normalized Temperature-Scaled Cross Entropy) loss to maximize similarity between positive pairs and minimize similarity with negative samples:</p>

\[\ell_{i,j}
= - \log 
\frac{
    \exp(\operatorname{sim}(z_i, z_j)/\tau)
}{
    \sum_{k \neq i} \exp(\operatorname{sim}(z_i, z_k)/\tau)
}\]

<p>$\tau$ is the temperature parameter controlling distribution sharpness. Appropriate temperature parameter can help model learn from hard negative samples.
sim() is cosine similarity.
(i, j) is a positive pair, and all other images in the batch act as negatives.</p>

<h3 id="2-workflow">2. Workflow</h3>
<ol>
  <li>Sample a batch of N images.</li>
  <li>
    <p>Applying two independently sampled data augmentations to each image. 
\(x \rightarrow x_i',\, x_j'\)
This produces two correlated views of the same image. All other augmented images in the batch serve as negative examples.</p>
  </li>
  <li>
    <p>Each augmented view is passed through the encoder to obtain representations:</p>

\[h = f_{\text{encoder}}(x')\]
  </li>
  <li>
    <p>The projection head maps representations into a space where contrastive loss is applied:</p>

\[z = g_{\text{proj}}(h)\]
  </li>
  <li>SimCLR uses the NT-Xent loss to increase similarity between positive pairs and decrease similarity with negative samples.</li>
</ol>

<h3 id="3-key-findings">3. Key Findings</h3>
<p>Experiment Setting:
Using ResNet-50 as base encoder, and two layer MLP projection head. Training at 4096 batch size and 100 epoches. SimCLR able to achieve 76.5% Top-1 accuracy on ImageNet[1].</p>

<p>Large Batch Sizes: SimCLR demonstrates that more negative samples is better for contrastive learning. However, training large batch using standard SGD/Momentum is unstable. Therefore, SimCLR uses LARS optimizer.</p>

<p>Data Augmentation: SimCLR relies on strong augmentations (crop, color jitter, Gaussian blur, etc.) to create meaningful positive pairs. No single augmentation (e.g., only cropping or only color jitter) is sufficient to learn high-quality representations. The model can still solve the contrastive prediction task with high accuracy, but the representations remain poor unless augmentations are combined, as shown in Fig 2 that the diagnoal entries are lower than off-diagnoal entries. A particularly important finding is that the composition of random cropping + random color distortion produces the strongest results. If only using random cropping, network will find the shortcut that most patches will share similar color distribution[1].</p>

<p>Contrastive learning benefits from bigger model and longer training. 
<img src="/CS163-Projects-2025Fall/assets/images/team40/simclr_aug.png" alt="SimCLR Aug" />
<em>Fig 2. Impact of combining data augmentations on representation quality in SimCLR</em> [1].</p>

<h2 id="masked-image-modelling-mae">Masked Image Modelling (MAE)</h2>
<p>Masked Autoencoders are a self-supervised learning method for masked image modeling. The model learns to reconstruct missing image patches using only a set of visible patches[2].</p>
<h3 id="1-model-structure-1">1. Model Structure</h3>

<p><img src="/CS163-Projects-2025Fall/assets/images/team40/mae.png" alt="SimCLR Aug" />
<em>Fig 2. Architecture of Masked Autoencoders (MAE)</em> [2].</p>

<h4 id="asymmetric-encoder">Asymmetric Encoder</h4>
<p>The encoder is a ViT that only processes visible patches. Because only small part of image is visible to encoder when using high masking ratio, the encoder computation and memory cost are substantially reduced. The encoder learns semantic, high-level features.</p>

<h4 id="lightweight-decoder">Lightweight Decoder</h4>
<p>The decoder receives both the encoded visible patch embeddings and a set of mask tokens that represent missing patches. Mask tokens are shared learned vectors with positional embeddings indicates where a patch should appear. The decoder reconstructs pixel values for all patches, and its output channel equals the number of pixels per patch, which is later reshaped back into image format. The decoder is used only during pre-training, not for downstream tasks, hence the design of it can be lightweight.</p>

<h4 id="normalized-pixel-reconstruction-variant">Normalized Pixel Reconstruction Variant</h4>
<p>MAE also evaluates reconstruction using normalized pixel values rather than raw RGB pixel values.</p>

\[\tilde{x} = \frac{x - \mu_{\text{patch}}}{\sigma_{\text{patch}}}\]

<p>Using normalized targets prevents the model from overfitting to global color biases and encourages learning of structure, texture, and spatial patterns, which are more useful for downstream tasks.</p>

<h3 id="2-workflow-1">2. Workflow</h3>

<p>The MAE pre-training pipeline works as follow:</p>

<ol>
  <li>Split input image into non-overlapping patches and convert them into token via linear projection.</li>
  <li>Random shuffle patch tokens and select a subset as visible tokens; rest of patches will be masked.</li>
  <li>Feed only the visible patch tokens into the ViT encoder. The encoder will output latent representations for visible patches.</li>
  <li>Create mask tokens for all removed patches and append mask tokens to encoder outputs.</li>
  <li>Unshuffle the sequence to restore the original spatial ordering.</li>
  <li>Feed the visible embeddings + mask tokens into decoder.</li>
  <li>The decoder predicts pixel values for all patches.</li>
  <li>Compute MSE loss only using masked patches.
For Masked patches M,</li>
</ol>

\[L_{\text{MAE}}
= \frac{1}{|M|}
\sum_{i \in M}
\lVert \hat{x}_i - x_i \rVert^{2}\]

<h3 id="3-key-findings-and-results">3. Key Findings and Results</h3>

<p>Experiment Setting:
Pre-training performed on ImageNet-1K using ViT-Large (ViT-L/16) as the backbone.<br />
Result: Baseline MAE with ViT-L achieve 84.9% accuracy on ImageNet-1K, while using ViT-H can achieve 87.8% accuracy[2].</p>

<p>Masking Ratio: A very high masking ratio of around 75% works best for both linear probing and fine-tuning, which shows that MAE benefits from massive masking[2]. This is because high masking ratio prevent model from simply learning from surrounding patches without learning from high-level information. In addition, the authors show that an MAE pre-trained with a 75% mask ratio can still produce plausible reconstructions even when evaluated with much higher masking ratios, demonstrating strong generalization of the learned representations.</p>

<p><img src="/CS163-Projects-2025Fall/assets/images/team40/mask_ratio.png" alt="SimCLR Aug" />
<em>Fig 2. MAE reconstructions under increasing masking ratios</em> [2].</p>

<p>Decoder Depth: A shallow decoder yields weaker linear-probing accuracy because the encoder must learn too many low-level details that should normally be handled by the decoder.</p>

<p>Mask Token Placement: Adding mask tokens after the encoder is better than adding them before. This is because encoder processes only real image data, which improves representation quality and save memory and compute.</p>

<p>Normalized Pixel Targets: Predicting normalized pixel values significantly improves reconstruction quality and downstream performance, as encoder is encouraged to learn structure, shape, and texture, instead of memorizing absolute pixel colors.</p>

<p>Minimal Augmentation: MAE performs well without strong data augmentation. Unlike contrastive learning such as SimCLR, MAE relies primarily on the masking operation as its augmentation.</p>

<h2 id="dino-self-distillation-with-no-labels">DINO: self-distillation with no labels</h2>

<p>DINO (self-distillation with no labels) is a self-supervised learning framework based on knowledge co-distillation, where a student network is trained to match the output distribution produced by a teacher network[3]. <br />
Both networks share the same architecture (e.g., ViT or ResNet) and consist of a backbone encoder followed by a projection head.</p>

<h3 id="model-structure">Model Structure</h3>

<p><img src="/CS163-Projects-2025Fall/assets/images/team40/dino.png" alt="SimCLR Aug" />
<em>Fig 5. Teacher-Student Training Framework in DINO</em> [3].</p>

<h4 id="teacher-student-symmetry">Teacher-Student Symmetry</h4>
<p>Student and teacher have identical network structures. Only the student receives gradient updates via SGD. The teacher parameters are updated using an exponential moving average (EMA) of the student:</p>

\[\theta_{\text{teacher}} \leftarrow \alpha \theta_{\text{teacher}} + (1-\alpha)\theta_{\text{student}}\]

<p>where \(\alpha\) follows a cosine schedule increasing from 0.996 to 1.</p>

<h4 id="output-distribution">Output distribution</h4>
<p>Both networks produce a probability distribution by applying a softmax with temperature:</p>

\[P = \text{softmax}\!\left(\frac{z}{\tau}\right)\]

<p>The student uses a higher temperature \(\tau\) to avoid over-confidence, while the teacher uses a low temperature \(\tau\) to produce informative targets.</p>

<h3 id="workflow">Workflow</h3>
<ol>
  <li>
    <p>Given an input image, DINO generates a set of augmented views V: (1) Two global crops x1 and x2 (resolution 224 × 224), (2) multiple local crops (resolution 96 × 96).</p>
  </li>
  <li>
    <p>Teacher only processes global views, and student processes all crops. This asymmetry teaches the student viewpoint invariance and encourages learning high-level semantic representations.</p>
  </li>
  <li>
    <p>The objective is to make the student output distribution match the teacher’s across corresponding views. This is done by minimizing the cross enrtopy loss with respect to student parameter:</p>

\[L = - \sum_{k} P^{(t)}_{k} \log\left(P^{(s)}_{k}\right)\]
  </li>
</ol>

<p>where \(P^{(t)}_{k}\) denotes the probability from teacher network to the \(k\)-th output dimension, and \(P^{(s)}_{k}\) denotes the probability from the student network. The summation is taken over all output dimensions \(k\).</p>

<ol>
  <li>
    <p>Student network’s parameters are updated via SGD, and teacher network’s parameter are updated using EMA of student weights (no backpropagation).</p>
  </li>
  <li>
    <p>Both networks use a projection head (similar to SwAV) to produce the representations used for distillation. The backbone embeddings are used later for downstream tasks</p>
  </li>
</ol>

<h3 id="key-findings--techniques">Key Findings &amp; techniques</h3>

<p>Avoiding Collapse:
DINO achieves non-trivial representations without negative samples by combining three stabilizing mechanisms:</p>
<ol>
  <li>Centering: Maintaining balanced activations across dimensions and preventing the model from collapsing to a single dominant feature or neuron.</li>
  <li>Sharpening: Using low-temperature softmax on teacher outputs to ensure teacher outputs are peaked and non-uniform.</li>
  <li>EMA Teacher Updating: Teacher parameters are updated slowly to provide stable optimization in training.</li>
</ol>

<p>Multi-crop training: DINO reveals that multi-crop training is highly effective for learning viewpoint invariant representations. By training the student on both global and local views while restricting the teacher to global views only, DINO encourages the model to connect fine-grained local details with global semantic context.</p>

<p>Patch size: The performance will be improved if using smaller patch size, even though more memory will be taken.</p>

<p>Semantic properties: The self attention map of DINO-pretrained ViT align well with object boundary as shown in Fig 6, which mean that self-distillation not only improves downstream performance but also leads to learning more interpretable and spatially meaningful representations.</p>

<p><img src="/CS163-Projects-2025Fall/assets/images/team40/dino_feature.png" alt="SimCLR Aug" />
<em>Fig 5. Attention map of DINO pretrained ViT</em> [3].</p>

<h2 id="conclusion">Conclusion</h2>
<p>Self-supervised learning enables models to learn meaningful representations directly from unlabeled data. In this report, we examined three representative self-supervised approaches—SimCLR, Masked Autoencoders (MAE), and DINO. SimCLR uses strong data augmentations and large batches to learn discriminative representations. MAE approaches through the perspective of reconstructing the image, showing that high masking ratios can encourage models to focus on semantic structure rather than low-level pixel statistics. DINO introduces a self-distillation framework without negative samples and uses several stablizing techniques to learn invariant features and prevent collapsing. All these methods utilize the dataset itself to design pretext task and reduce reliance on labeled data while achieving competitive performance. As datasets continue to grow in size and labeling costs remain high, self-supervised learning is likely to play an increasingly important role in modern computer vision systems.</p>

<h2 id="reference">Reference</h2>

<p>[1] Chen, T., Kornblith, S., Norouzi, M., &amp; Hinton, G. (2020). A simple framework for contrastive learning of visual representations. In International Conference on Machine Learning (pp. 1597-1607). PMLR.</p>

<p>[2] He, K., Chen, X., Xie, S., Li, Y., Dollár, P., &amp; Girshick, R. (2022). Masked autoencoders are scalable vision learners. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition (pp. 16000-16009).</p>

<p>[3] Caron, M., Touvron, H., Misra, I., Jégou, H., Mairal, J., Bojanowski, P., &amp; Joulin, A. (2021). Emerging properties in self-supervised vision transformers. In Proceedings of the IEEE/CVF International Conference on Computer Vision (pp. 9650-9660).</p>

<hr />]]></content><author><name>Audrey Dong</name></author><summary type="html"><![CDATA[Self-supervised Learning is a way for models to learn useful features without relying on labeled data. The model can create its own learning targets from the structure of the data. This method becomes popular in computer vision and many other fields because it makes use of large amounts of unlabeled data and can produce strong representations for downstream tasks. In this paper, we introduce the basic ideas behind self-supervised learning and discuss several common methods and why they are effective.]]></summary></entry><entry><title type="html">Post Template</title><link href="http://localhost:4000/CS163-Projects-2025Fall/2024/01/01/team00-instruction-to-post.html" rel="alternate" type="text/html" title="Post Template" /><published>2024-01-01T00:00:00+08:00</published><updated>2024-01-01T00:00:00+08:00</updated><id>http://localhost:4000/CS163-Projects-2025Fall/2024/01/01/team00-instruction-to-post</id><content type="html" xml:base="http://localhost:4000/CS163-Projects-2025Fall/2024/01/01/team00-instruction-to-post.html"><![CDATA[<blockquote>
  <p>This block is a brief introduction of your project. You can put your abstract here or any headers you want the readers to know.</p>
</blockquote>

<!--more-->
<ul id="markdown-toc">
  <li><a href="#main-content" id="markdown-toc-main-content">Main Content</a></li>
  <li><a href="#basic-syntax" id="markdown-toc-basic-syntax">Basic Syntax</a>    <ul>
      <li><a href="#image" id="markdown-toc-image">Image</a></li>
      <li><a href="#table" id="markdown-toc-table">Table</a></li>
      <li><a href="#code-block" id="markdown-toc-code-block">Code Block</a></li>
      <li><a href="#formula" id="markdown-toc-formula">Formula</a></li>
      <li><a href="#more-markdown-syntax" id="markdown-toc-more-markdown-syntax">More Markdown Syntax</a></li>
    </ul>
  </li>
  <li><a href="#reference" id="markdown-toc-reference">Reference</a></li>
</ul>

<h2 id="main-content">Main Content</h2>
<p>Your survey starts here. You can refer to the <a href="https://github.com/lilianweng/lil-log/tree/master/_posts">source code</a> of <a href="https://lilianweng.github.io/lil-log/">lil’s blogs</a> for article structure ideas or Markdown syntax. We’ve provided a <a href="https://ucladeepvision.github.io/CS188-Projects-2022Winter/2017/06/21/an-overview-of-deep-learning.html">sample post</a> from Lilian Weng and you can find the source code <a href="https://raw.githubusercontent.com/UCLAdeepvision/CS188-Projects-2022Winter/main/_posts/2017-06-21-an-overview-of-deep-learning.md">here</a></p>

<h2 id="basic-syntax">Basic Syntax</h2>
<h3 id="image">Image</h3>
<p>Please create a folder with the name of your team id under /assets/images/, put all your images into the folder and reference the images in your main content.</p>

<p style="width: 400px; max-width: 100%;">You can add an image to your survey like this:
<img src="/CS163-Projects-2025Fall/assets/images/UCLAdeepvision/object_detection.png" alt="YOLO" /></p>
<p><em>Fig 1. YOLO: An object detection method in computer vision</em> [1].</p>

<p>Please cite the image if it is taken from other people’s work.</p>

<h3 id="table">Table</h3>
<p>Here is an example for creating tables, including alignment syntax.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left"> </th>
      <th style="text-align: center">column 1</th>
      <th style="text-align: right">column 2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">row1</td>
      <td style="text-align: center">Text</td>
      <td style="text-align: right">Text</td>
    </tr>
    <tr>
      <td style="text-align: left">row2</td>
      <td style="text-align: center">Text</td>
      <td style="text-align: right">Text</td>
    </tr>
  </tbody>
</table>

<h3 id="code-block">Code Block</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># This is a sample code block
import torch
print (torch.__version__)
</code></pre></div></div>

<h3 id="formula">Formula</h3>
<p>Please use latex to generate formulas, such as:</p>

\[\tilde{\mathbf{z}}^{(t)}_i = \frac{\alpha \tilde{\mathbf{z}}^{(t-1)}_i + (1-\alpha) \mathbf{z}_i}{1-\alpha^t}\]

<p>or you can write in-text formula \(y = wx + b\).</p>

<h3 id="more-markdown-syntax">More Markdown Syntax</h3>
<p>You can find more Markdown syntax at <a href="https://www.markdownguide.org/basic-syntax/">this page</a>.</p>

<h2 id="reference">Reference</h2>
<p>Please make sure to cite properly in your work, for example:</p>

<p>[1] Redmon, Joseph, et al. “You only look once: Unified, real-time object detection.” <em>Proceedings of the IEEE conference on computer vision and pattern recognition</em>. 2016.</p>

<hr />]]></content><author><name>UCLAdeepvision</name></author><summary type="html"><![CDATA[This block is a brief introduction of your project. You can put your abstract here or any headers you want the readers to know.]]></summary></entry></feed>